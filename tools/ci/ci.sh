#!/bin/bash
# Template writing guide — Argbash 2.6.1 documentation(http://argbash.readthedocs.io/en/stable/guide.html#argbash-api)
# Updated by intret
# Created by argbash-init v2.6.1
# ARG_OPTIONAL_BOOLEAN([build],[],[A bool value(on/off) indicated that whether the script will executes the gradle-building process],[on])
# ARG_OPTIONAL_SINGLE([flavor],[],[The flavor-name of gradle project you wanted to build, for example 'production'],[all-flavors])
# ARG_OPTIONAL_SINGLE([build-type],[],[The build-type of gradle project you wanted to build, for example 'debug','release'],[all-types])
# ARG_OPTIONAL_BOOLEAN([collect-apk],[],[A bool value(on/off) indicated that whether the script will executes the collect-apk process],[on])
# ARG_OPTIONAL_SINGLE([collect-apk-dir],[],[The directory of all output .apk files],[ci-outputs/apk])
# ARG_OPTIONAL_BOOLEAN([debug],[d],[A bool value(on/off) indicated that whether the script will print the debug information],[off])
# ARG_HELP([<The general help message of ci.sh>])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.6.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

begins_with_short_option()
{
	local first_option all_short_options
	all_short_options='dh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_build="on"
_arg_flavor="all-flavors"
_arg_build_type="all-types"
_arg_collect_apk="on"
_arg_collect_apk_dir="ci-outputs/apk"
_arg_debug="off"

print_help ()
{
	printf '%s\n' "<The general help message of ci.sh>"
	printf 'Usage: %s [--(no-)build] [--flavor <arg>] [--build-type <arg>] [--(no-)collect-apk] [--collect-apk-dir <arg>] [-d|--(no-)debug] [-h|--help]\n' "$0"
	printf '\t%s\n' "--build,--no-build: A bool value(on/off) indicated that whether the script will executes the gradle-building process (on by default)"
	printf '\t%s\n' "--flavor: The flavor-name of gradle project you wanted to build, for example 'production' (default: 'all-flavors')"
	printf '\t%s\n' "--build-type: The build-type of gradle project you wanted to build, for example 'debug','release' (default: 'all-types')"
	printf '\t%s\n' "--collect-apk,--no-collect-apk: A bool value(on/off) indicated that whether the script will executes the collect-apk process (on by default)"
	printf '\t%s\n' "--collect-apk-dir: The directory of all output .apk files (default: 'ci-outputs/apk')"
	printf '\t%s\n' "-d,--debug,--no-debug: A bool value(on/off) indicated that whether the script will print the debug information (off by default)"
	printf '\t%s\n' "-h,--help: Prints help"
}

parse_commandline ()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			--no-build|--build)
				_arg_build="on"
				test "${1:0:5}" = "--no-" && _arg_build="off"
				;;
			--flavor)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_flavor="$2"
				shift
				;;
			--flavor=*)
				_arg_flavor="${_key##--flavor=}"
				;;
			--build-type)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_build_type="$2"
				shift
				;;
			--build-type=*)
				_arg_build_type="${_key##--build-type=}"
				;;
			--no-collect-apk|--collect-apk)
				_arg_collect_apk="on"
				test "${1:0:5}" = "--no-" && _arg_collect_apk="off"
				;;
			--collect-apk-dir)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_collect_apk_dir="$2"
				shift
				;;
			--collect-apk-dir=*)
				_arg_collect_apk_dir="${_key##--collect-apk-dir=}"
				;;
			-d|--no-debug|--debug)
				_arg_debug="on"
				test "${1:0:5}" = "--no-" && _arg_debug="off"
				;;
			-d*)
				_arg_debug="on"
				_next="${_key##-d}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


# ------------------------------------------------
# Shell initialization
# ------------------------------------------------
debug_echo()
{
    if [[ $_arg_debug = 'on' ]]; then
	    echo $*
	fi
}

info_echo()
{
	echo $*
}

error_echo()
{
	echo "[error] $*"
}

# change working directory to script file directory
cd ${0%/*}
debug_echo "cd:$(pwd)"

# change directory to project root directory
# TODO: auto detect the project root directory with gradle.properties/gradlew files or with .idea folder
cd ../..
debug_echo "cd:$(pwd)"

# save some directory path to vars
SHELL_WORK_DIR=$(pwd)
SHELL_PARAMS=$*

# ------------------------------------------------
# User defined project variable
# ------------------------------------------------
PROJ_CI_TOOLS_REL_DIR=./tools/ci/cli
PROJ_CI_TOOLS_ABS_DIR=
PROJ_NAME=PicGo

debug_echo "SHELL_WORK_DIR=$SHELL_WORK_DIR"



if [[ ! -d "./tools/ci" ]]; then
	echo "[ERROR] There isn't a './tools/ci' directory in dir : $SHELL_WORK_DIR"
	exit 1
fi

init_tool_dir()
{
    debug_echo "--init tool directory--"

	mkdir -p $PROJ_CI_TOOLS_REL_DIR

	# Get full path
	PROJ_CI_TOOLS_ABS_DIR="$(cd "$(dirname "$PROJ_CI_TOOLS_REL_DIR")"; pwd)/$(basename "$PROJ_CI_TOOLS_REL_DIR")"
}
init_tool_dir

init_tool_path()
{
    debug_echo "--init tool path--"

	export PATH=$PROJ_CI_TOOLS_ABS_DIR:$PATH
	if [[ "$(uname)" = "Darwin" ]]; then
		export PATH=$PROJ_CI_TOOLS_ABS_DIR/osx-amd64:$PATH
	elif [[ "$(uname)" = "Linux" ]]; then
		export PATH=$PROJ_CI_TOOLS_ABS_DIR/linux-amd64:$PATH
	else
		echo "* 未知操作系统，不知道如何初始化工具"
		return 1
	fi

	debug_echo "PATH=$PATH"
}
init_tool_path

# ------------------------------------------------
# Gradle initialization
# ------------------------------------------------------------------------------

init_gradle()
{
    debug_echo "--init gradle--"

	export GRADLE_USER_HOME=$(pwd)/.gradle
	chmod +x ./gradlew

	debug_echo "chmod ./gradlew"
}
init_gradle



# $1 flavorName : like "production"
# $2 buildType : like "debug", "release"
build_apk()
{
	echo "---------------------------------------------------------------------"
	echo "   Build project and generate apk files"
	echo "---------------------------------------------------------------------"

	if [[ $_arg_build = "off" ]]; then
		return 0
	fi

    chmod +x ./gradlew

    if [[ $_arg_debug = "on" ]]; then
        debug_echo "All assemble tasks:"
        ./gradlew tasks|grep assemble
    fi

	if [[ "$_arg_flavor" = "all-flavors" ]]; then
		# Assemble release build type
		# package all flavor apk into a large .tar.gz file
		# upload .tar.gz to aliyun
		# upload specified version to aliyun

		echo "Build $PROJ_NAME project ($_arg_flavor)"
		./gradlew clean assemble
    else

        if [[ $_arg_build_type = "all-types" ]]; then
            echo "Build $PROJ_NAME project ($_arg_flavor all-types)"
            ./gradlew clean "assemble$_arg_flavor"
        else
            echo "Build $PROJ_NAME project ($_arg_flavor $_arg_build_type)"
            ./gradlew clean "assemble$_arg_flavor$_arg_build_type"
        fi
    fi
}

# $1 flavorName : string likes "googleplay", "ali", "yyb"
# $2 buildType : string, one of these : "debug", "release"
get_apk_name()
{
	jq ".[].path" $1
}

# $1 flavorName : like "play","ali","wandoujia"
# $2 buildType : like "debug", "release"
# $3 target dir
# the current directory should be : app/build/outputs
copy_apk_to_dir()
{
	debug_echo "copy_apk_to_dir() arguments : $*"

	outputJsonFile="apk/$1/$2/output.json"
	debug_echo "use output json file : $outputJsonFile"

	cpApkName=`get_apk_name $outputJsonFile`
	if [[ $cpApkName = "" ]]; then
	    error_echo "get apk file name failed."
        return 1
	fi

	# remove character " from begin and end of string.
	cpApkName="${cpApkName%\"}"
	cpApkName="${cpApkName#\"}"

	debug_echo "apk file name : $cpApkName"
    cpApkFile="apk/$1/$2/$cpApkName"
	cp "$cpApkFile" "$3" || return 1
	return 0
}

collect_apk()
{
    echo "---------------------------------------------------------------------"
	echo "   Collect apk files to $_arg_collect_apk_dir"
	echo "---------------------------------------------------------------------"

	info_echo "pwd = $(pwd)"

    if [[ $_arg_collect_apk = "on" ]]; then

        if ! $_arg_collect_apk_dir = ""; then
            [ -d "$_arg_collect_apk_dir" ] && rm -rf "$_arg_collect_apk_dir"
            mkdir -p "$_arg_collect_apk_dir" && info_echo "created $_arg_collect_apk_dir"
        fi

        info_echo "Collecting the output .apk files to directory '$_arg_collect_apk_dir'"


        if [[ $_arg_build_type = "all-flavors" ]]; then
            # Assemble release build type
            # package all flavor apk into a large .tar.gz file
            # upload .tar.gz to aliyun
            # upload specified version to aliyun

		    echo "Copy all flavor outputs to $_arg_collect_apk_dir"

            find . -name \*.apk -exec cp -prv '{}' '$_arg_collect_apk_dir' ';'

        else

            if [[ $_arg_build_type = "all-types" ]]; then
                echo "Copy flavor $_arg_flavor 's all build types outputs to $_arg_collect_apk_dir"

            else
                echo "Copy $_arg_flavor $_arg_build_type to $_arg_collect_apk_dir"
                copy_apk_to_dir "$_arg_flavor" "$_arg_build_type" "$_arg_collect_apk_dir"
                if [[ $? -gt 0 ]]; then
                    error_echo "collect apk file failed."
                    return 1
                else
                    info_echo "all .apk files in dir '$_arg_collect_apk_dir':"
                    ls "$_arg_collect_apk_dir"
                fi
            fi
        fi

    else
        info_echo "we don't collect .apk files."
    fi
}

pre_upload()
{
    debug_echo "--pre upload--"
    collect_apk && info_echo "collect .apk file success."
}

main()
{
    echo "PROJ_CI_TOOLS_REL_DIR = $PROJ_CI_TOOLS_REL_DIR"
    echo "PROJ_CI_TOOLS_ABS_DIR = $PROJ_CI_TOOLS_ABS_DIR"
    echo "PROJ_NAME = $PROJ_NAME"

    echo "_arg_build_type=$_arg_build_type"
    echo "_arg_flavor=$_arg_flavor"
    echo "_arg_collect_apk_dir=$_arg_collect_apk_dir"
    echo "_arg_collect_apk=$_arg_collect_apk"
    echo "_arg_debug=$_arg_debug"
    echo "_arg_build=$_arg_build"

	build_apk || return 1

	pushd app/build/outputs
		BUILD_DATE=$(date '+%Y%m%d_%H%M%S')
		pre_upload
		#upload_files_to_server
	popd
}
#test
main


# ] <-- needed because of Argbash
